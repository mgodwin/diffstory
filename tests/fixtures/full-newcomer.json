{
  "source": "https://github.com/acme/webapp/pull/42",
  "title": "Add user authentication with JWT tokens",
  "knowledgeLevel": "none",
  "criticality": {
    "level": "high",
    "explanation": "This is a security-critical authentication flow that introduces middleware affecting all routes, with token storage strategies that have direct security implications.",
    "risks": ["JWT secret leak could compromise all user sessions", "Missing token rotation allows indefinite session reuse", "Incorrect middleware ordering could leave routes unprotected"]
  },
  "approachEvaluation": {
    "verdict": "acceptable",
    "summary": "JWT-based auth is a reasonable choice for this API. The implementation follows standard patterns but has room for improvement.",
    "perspectives": [
      {
        "role": "security",
        "concern": "JWT secrets are loaded via non-null assertion on `process.env` with no startup validation. If the env var is missing, the app starts but produces garbage tokens. Token refresh doesn't invalidate the old refresh token, allowing token replay if a cookie is stolen.",
        "severity": "high"
      },
      {
        "role": "sre",
        "concern": "No logging on authentication failures — when users report login issues, there's no trail to follow. The `catch` block in `refreshToken` swallows all errors identically, making it impossible to distinguish expired tokens from malformed ones in production.",
        "severity": "medium"
      },
      {
        "role": "consumer",
        "concern": "The error response shape varies between endpoints (`error` string vs potential Express default HTML). Consumers need to handle both. The access token lifetime (15m) isn't documented anywhere a client developer would find it.",
        "severity": "medium"
      }
    ],
    "alternatives": [
      {
        "title": "Session-based auth",
        "description": "Simpler for server-rendered apps, avoids token refresh complexity, but less suitable for API-first architectures."
      },
      {
        "title": "OAuth 2.0 with PKCE",
        "description": "More robust for production, supports third-party login, but significantly more complex to implement."
      }
    ]
  },
  "summary": "Implements **JWT-based authentication** for the web application. This includes a login endpoint, token generation, middleware for protected routes, and a `refreshToken` mechanism.\n\nThe implementation uses `bcrypt` for password hashing and stores refresh tokens in an **HTTP-only cookie** to mitigate XSS attacks.",
  "bigPicture": "This is a **Node.js Express** web application that serves a REST API for a task management system. Users can create, read, update, and delete tasks organized into projects.\n\nCurrently the API is *completely open* — anyone can access any endpoint. This PR adds the authentication layer that will protect all endpoints and associate tasks with specific users.\n\nThe app follows a standard MVC pattern: routes define URL mappings, controllers handle request logic, and models interact with a PostgreSQL database via Knex.js.",
  "sideEffects": [
    {
      "area": "Frontend auth flow",
      "description": "Any frontend code that calls /api/auth/login will receive a new response shape with accessToken in the body. Existing clients expecting a session cookie will break.",
      "severity": "high"
    },
    {
      "area": "Existing route handlers",
      "description": "All /api/tasks routes now require a valid JWT in the Authorization header. Integration tests or scripts hitting these endpoints without tokens will fail.",
      "severity": "high"
    },
    {
      "area": "cookie-parser dependency",
      "description": "The refresh token flow reads from req.cookies, which requires cookie-parser middleware to be installed. If it's missing, refresh will silently fail.",
      "severity": "medium"
    }
  ],
  "glossary": [
    { "term": "JWT", "definition": "JSON Web Token — a compact, self-contained token format used to securely transmit information between parties as a JSON object" },
    { "term": "Refresh token", "definition": "A long-lived token used to obtain new access tokens without requiring the user to re-authenticate" },
    { "term": "bcrypt", "definition": "A password hashing function designed to be slow, making brute-force attacks computationally expensive" },
    { "term": "HTTP-only cookie", "definition": "A cookie flag that prevents JavaScript from accessing the cookie value, mitigating XSS attacks" }
  ],
  "testCoverage": [
    {
      "file": "src/controllers/auth.ts",
      "function": "login",
      "status": "covered",
      "testLocation": "tests/auth.test.ts",
      "notes": "Happy path and invalid credentials tested"
    },
    {
      "file": "src/middleware/authenticate.ts",
      "function": "authenticate",
      "status": "partial",
      "testLocation": "tests/middleware.test.ts",
      "notes": "Missing test for expired token scenario"
    },
    {
      "file": "src/controllers/auth.ts",
      "function": "refreshToken",
      "status": "uncovered",
      "notes": "No tests written yet"
    }
  ],
  "narratives": [
    {
      "id": "narrative-1",
      "title": "Auth controller",
      "bigPicture": "This narrative covers the authentication controller — the central piece that handles user login and token management. If you're new to this codebase, think of this as the \"gatekeeper\" that decides who gets in and hands out access passes (JWT tokens).",
      "summary": "The core authentication logic — login, token generation, and refresh. This is where credentials are validated and tokens are issued.",
      "steps": [
        {
          "id": "step-1",
          "title": "Login endpoint",
          "blurb": "The `login` function validates credentials against the database using **bcrypt** comparison, then generates both an access token and a refresh token. The access token is returned in the response body while the refresh token is set as an *HTTP-only cookie*.",
          "hunks": [
            {
              "id": "hunk-1",
              "file": "src/controllers/auth.ts",
              "startLine": 1,
              "endLine": 35,
              "diff": "@@ -0,0 +1,35 @@\n+import { Request, Response } from 'express';\n+import bcrypt from 'bcrypt';\n+import jwt from 'jsonwebtoken';\n+import { findUserByEmail } from '../models/user';\n+\n+const ACCESS_SECRET = process.env.JWT_SECRET!;\n+const REFRESH_SECRET = process.env.JWT_REFRESH_SECRET!;\n+\n+export async function login(req: Request, res: Response) {\n+  const { email, password } = req.body;\n+\n+  const user = await findUserByEmail(email);\n+  if (!user) {\n+    return res.status(401).json({ error: 'Invalid credentials' });\n+  }\n+\n+  const valid = await bcrypt.compare(password, user.passwordHash);\n+  if (!valid) {\n+    return res.status(401).json({ error: 'Invalid credentials' });\n+  }\n+\n+  const accessToken = jwt.sign(\n+    { userId: user.id, role: user.role },\n+    ACCESS_SECRET,\n+    { expiresIn: '15m' }\n+  );\n+\n+  const refreshToken = jwt.sign(\n+    { userId: user.id },\n+    REFRESH_SECRET,\n+    { expiresIn: '7d' }\n+  );\n+\n+  res.cookie('refreshToken', refreshToken, {\n+    httpOnly: true,\n+    secure: process.env.NODE_ENV === 'production',\n+    sameSite: 'strict',\n+    maxAge: 7 * 24 * 60 * 60 * 1000\n+  });\n+\n+  return res.json({ accessToken });\n+}",
              "fileContext": "This file contains the authentication controller — it handles login requests and token operations for the Express API.",
              "annotations": [
                {
                  "id": "ann-1",
                  "type": "risk",
                  "lineMatch": "process.env.JWT_SECRET!",
                  "content": "The non-null assertion `!` on environment variables will throw at runtime if they're missing. Consider validating at startup."
                },
                {
                  "id": "ann-2",
                  "type": "provocation",
                  "lineMatch": "if (!user)",
                  "content": "Using the same error message for 'user not found' and 'wrong password' is a good security practice — it prevents user enumeration attacks."
                },
                {
                  "id": "ann-3",
                  "type": "alternative",
                  "lineMatch": "{ expiresIn: '15m' }",
                  "content": "15 minutes is a reasonable access token lifetime, but some teams prefer 5 minutes for higher-security applications."
                }
              ]
            }
          ]
        },
        {
          "id": "step-2",
          "title": "Refresh token endpoint",
          "blurb": "The `refreshToken` function reads the refresh token from the HTTP-only cookie, validates it, and issues a new access token. This lets the client stay authenticated without storing sensitive tokens in JavaScript-accessible storage.",
          "hunks": [
            {
              "id": "hunk-2",
              "file": "src/controllers/auth.ts",
              "startLine": 37,
              "endLine": 58,
              "diff": "@@ -35,0 +37,22 @@\n+export async function refreshToken(req: Request, res: Response) {\n+  const token = req.cookies?.refreshToken;\n+  if (!token) {\n+    return res.status(401).json({ error: 'No refresh token' });\n+  }\n+\n+  try {\n+    const payload = jwt.verify(token, REFRESH_SECRET) as { userId: string };\n+    const user = await findUserByEmail(payload.userId);\n+    if (!user) {\n+      return res.status(401).json({ error: 'User not found' });\n+    }\n+\n+    const accessToken = jwt.sign(\n+      { userId: user.id, role: user.role },\n+      ACCESS_SECRET,\n+      { expiresIn: '15m' }\n+    );\n+\n+    return res.json({ accessToken });\n+  } catch {\n+    return res.status(401).json({ error: 'Invalid refresh token' });\n+  }\n+}",
              "fileContext": "This file contains the authentication controller — it handles login requests and token operations for the Express API.",
              "annotations": [
                {
                  "id": "ann-4",
                  "type": "question",
                  "lineMatch": "findUserByEmail(payload.userId)",
                  "content": "This looks up the user by `payload.userId` using `findUserByEmail` — should this be `findUserById` instead?"
                },
                {
                  "id": "ann-5",
                  "type": "edge_case",
                  "lineMatch": "req.cookies?.refreshToken",
                  "content": "If `cookie-parser` middleware isn't installed, `req.cookies` will be undefined. The optional chaining handles it gracefully but the error message won't be very helpful for debugging."
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "id": "narrative-2",
      "title": "Auth middleware",
      "bigPicture": "This narrative walks through the middleware layer — the code that runs before every protected request to check whether the caller has a valid token. It also shows how the middleware is wired into the Express router.",
      "summary": "The middleware that protects routes by validating the JWT access token on incoming requests.",
      "steps": [
        {
          "id": "step-3",
          "title": "Token validation middleware",
          "blurb": "The `authenticate` middleware extracts the JWT from the `Authorization` header, verifies it, and attaches the decoded payload to `req.user` for downstream handlers.",
          "hunks": [
            {
              "id": "hunk-3",
              "file": "src/middleware/authenticate.ts",
              "startLine": 1,
              "endLine": 24,
              "diff": "@@ -0,0 +1,24 @@\n+import { Request, Response, NextFunction } from 'express';\n+import jwt from 'jsonwebtoken';\n+\n+const ACCESS_SECRET = process.env.JWT_SECRET!;\n+\n+export function authenticate(req: Request, res: Response, next: NextFunction) {\n+  const header = req.headers.authorization;\n+  if (!header?.startsWith('Bearer ')) {\n+    return res.status(401).json({ error: 'Missing token' });\n+  }\n+\n+  const token = header.slice(7);\n+\n+  try {\n+    const payload = jwt.verify(token, ACCESS_SECRET);\n+    (req as any).user = payload;\n+    next();\n+  } catch (err) {\n+    return res.status(401).json({ error: 'Invalid or expired token' });\n+  }\n+}",
              "fileContext": "This middleware file is loaded by the Express router and runs before any protected route handler.",
              "annotations": [
                {
                  "id": "ann-6",
                  "type": "risk",
                  "lineMatch": "(req as any).user = payload",
                  "content": "Using `(req as any).user` bypasses TypeScript safety. Consider extending the Express Request type with a declaration merge."
                }
              ]
            }
          ]
        },
        {
          "id": "step-4",
          "title": "Apply middleware to routes",
          "blurb": "The authentication middleware is applied to all `/api/tasks` routes, requiring a valid JWT for any task operation.",
          "hunks": [
            {
              "id": "hunk-4",
              "file": "src/routes/index.ts",
              "startLine": 5,
              "endLine": 12,
              "diff": "@@ -4,3 +5,8 @@\n+import { authenticate } from '../middleware/authenticate';\n+import authRoutes from './auth';\n+\n+router.use('/api/auth', authRoutes);\n-router.use('/api/tasks', taskRoutes);\n+router.use('/api/tasks', authenticate, taskRoutes);",
              "fileContext": "The main router file that wires all route modules together in the Express application.",
              "annotations": [
                {
                  "id": "ann-7",
                  "type": "provocation",
                  "lineMatch": "authenticate, taskRoutes",
                  "content": "Auth routes are intentionally placed *before* the authenticate middleware so login/refresh endpoints remain public."
                }
              ]
            }
          ]
        }
      ]
    }
  ]
}
